[
  {
    "id": 290,
    "raw_problem": "# Write a function to replace all spaces in the given string with '%20'.\ndef replace_spaces(string):\n",
    "raw_solution": "  return string.replace(\" \", \"%20\")\n",
    "new_problem": "# Given a list of strings, replace all spaces in each string with '%20' and then concatenate all the modified strings into a single string. Finally, split the concatenated string by '%20' and return the resulting list of substrings.\ndef process_strings(string_list):\n",
    "new_solution": "  modified_strings = [replace_spaces(s) for s in string_list]\n  concatenated_string = ''.join(modified_strings)\n  return concatenated_string.split('%20')\n",
    "test_code": "assert process_strings(['hello world', 'goodbye space']) == ['hello', 'worldgoodbye', 'space']\nassert process_strings(['no_spaces', 'here']) == ['no_spaceshere']\nassert process_strings(['multiple spaces   here']) == ['multiple', 'spaces', '', '', 'here']"
  },
  {
    "id": 201,
    "raw_problem": "# Write a function to find the first adverb and their positions in a given sentence.\nimport re\ndef find_adverb_position(text):\n",
    "raw_solution": "    for m in re.finditer(r\"\\w+ly\", text):\n        return (m.start(), m.end(), m.group(0))\n",
    "new_problem": "# Write a function to find all adverbs and their positions in multiple sentences. The function should return a list of tuples where each tuple contains the start position, end position, and the adverb for each sentence.\nimport re\n\ndef find_all_adverbs_positions(sentences):\n",
    "new_solution": "    results = []\n    for sentence in sentences:\n        adverb_info = find_adverb_position(sentence)\n        if adverb_info:\n            results.append(adverb_info)\n    return results\n\ndef find_adverb_position(text):\n    for m in re.finditer(r\"\\w+ly\", text):\n        return (m.start(), m.end(), m.group(0))\n",
    "test_code": "assert find_all_adverbs_positions(['She quickly ran to the store.', 'He slowly walked home.']) == [(4, 11, 'quickly'), (3, 9, 'slowly')]\nassert find_all_adverbs_positions(['The dog barked loudly.', 'The cat meowed softly.']) == [(15, 21, 'loudly'), (15, 21, 'softly')]\nassert find_all_adverbs_positions(['There was no adverb in this sentence.']) == []"
  },
  {
    "id": 234,
    "raw_problem": "# Write a function to toggle the case of all characters in a string.\ndef toggle_string(string):\n",
    "raw_solution": " return string.swapcase()\n",
    "new_problem": "# Given a list of strings, write a function to toggle the case of all characters in each string and then concatenate the results into a single string, with each toggled string separated by a space.\ndef toggle_and_concatenate(strings):\n",
    "new_solution": "    return ' '.join([toggle_string(s) for s in strings])\n",
    "test_code": "assert toggle_and_concatenate(['Hello', 'World']) == 'hELLO wORLD'\nassert toggle_and_concatenate(['Python', 'Programming']) == 'pYTHON pROGRAMMING'\nassert toggle_and_concatenate(['aBcDeF']) == 'AbCdEf'\nassert toggle_and_concatenate(['123', '456']) == '123 456'\nassert toggle_and_concatenate([]) == ''"
  },
  {
    "id": 25,
    "raw_problem": "# Write a function to find the number of ways to partition a set of Bell numbers.\ndef bell_number(n):\n",
    "raw_solution": "    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \n",
    "new_problem": "# Given a list of integers representing the sizes of sets, write a function to find the total number of ways to partition all these sets combined.\ndef total_bell_numbers(sizes):\n",
    "new_solution": "    return sum(bell_number(size) for size in sizes)\n",
    "test_code": "assert total_bell_numbers([1, 2, 3]) == 8\nassert total_bell_numbers([0, 1, 2]) == 4\nassert total_bell_numbers([5, 5, 5]) == 156\nassert total_bell_numbers([10]) == 115975\nassert total_bell_numbers([0, 0, 0]) == 3"
  },
  {
    "id": 39,
    "raw_problem": "# Write a function to find nth centered hexagonal number.\ndef centered_hexagonal_number(n):\n",
    "raw_solution": "  return 3 * n * (n - 1) + 1\n",
    "new_problem": "# Given a list of integers representing the positions of points on a hexagonal grid, write a function to calculate the sum of the centered hexagonal numbers for each point in the list.\ndef sum_centered_hexagonal_numbers(points):\n",
    "new_solution": "    def centered_hexagonal_number(n):\n        return 3 * n * (n - 1) + 1\n    return sum(centered_hexagonal_number(point) for point in points)\n",
    "test_code": "assert sum_centered_hexagonal_numbers([1, 2, 3]) == 27\nassert sum_centered_hexagonal_numbers([4, 5]) == 98\nassert sum_centered_hexagonal_numbers([10]) == 271"
  },
  {
    "id": 362,
    "raw_problem": "# Write a python function to count the number of lists in a given number of lists.\ndef count_list(input_list):\n",
    "raw_solution": "    return sum(isinstance(e, list) for e in input_list)\n",
    "new_problem": "# Write a Python function to count the number of lists in a given list of lists of lists. The function should recursively count all the lists at any depth.\ndef count_lists_recursive(input_list):\n",
    "new_solution": "    count = count_list(input_list) \n    for element in input_list: \n        if isinstance(element, list): \n            count += count_lists_recursive(element) \n    return count\n",
    "test_code": "assert count_lists_recursive([[1, 2], [3, [4, 5]], 6]) == 3\nassert count_lists_recursive([1, 2, 3]) == 0\nassert count_lists_recursive([[[1], [2, [3]]], [4, [5, [6]]]]) == 7\nassert count_lists_recursive([]) == 0\nassert count_lists_recursive([[[[[]]]]]) == 4"
  },
  {
    "id": 102,
    "raw_problem": "# Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\ndef replace_blank(str1, char):\n",
    "raw_solution": "    return str1.replace(' ', char)\n",
    "new_problem": "# Write a function that takes in a list of strings and a character. The function should replace all blank spaces in each string with the given character, and then concatenate all the modified strings into a single string. Finally, return the concatenated string.\ndef replace_and_concatenate(str_list, char):\n",
    "new_solution": "    modified_strings = [replace_blank(s, char) for s in str_list]\n    return ''.join(modified_strings)\n",
    "test_code": "assert replace_and_concatenate(['hello world', 'goodbye space'], '-') == 'hello-worldgoodbye-space'\nassert replace_and_concatenate(['no spaces here'], '*') == 'no*spaces*here'\nassert replace_and_concatenate(['', 'empty string'], '_') == 'empty_string'"
  },
  {
    "id": 373,
    "raw_problem": "# Write a function that returns the list in a list of lists whose sum of elements is the highest.\ndef max_sum_list(lists):\n",
    "raw_solution": " return max(lists, key=sum)\n",
    "new_problem": "# Given a list of lists of lists, where each sub-list contains integers, write a function that returns the list of lists whose sum of elements is the highest among all sub-lists. If there are multiple lists with the same highest sum, return the first one encountered.\ndef max_sum_list_of_lists(list_of_lists):\n",
    "new_solution": "   return max(list_of_lists, key=lambda x: sum(max_sum_list(x)))\n",
    "test_code": "assert max_sum_list_of_lists([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]) == [[5, 6], [7, 8]]\nassert max_sum_list_of_lists([[[1], [2, 3]], [[4], [5, 6]]]) == [[4], [5, 6]]\nassert max_sum_list_of_lists([[[1, 2, 3], [4, 5]], [[6, 7], [8, 9]]]) == [[6, 7], [8, 9]]\nassert max_sum_list_of_lists([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]]) == [[9, 10], [11, 12]]"
  },
  {
    "id": 65,
    "raw_problem": "# Write a function to convert a string to a list of strings split on the space character.\ndef string_to_list(string):\n",
    "raw_solution": "    return string.split(\" \")\n",
    "new_problem": "# Write a function to convert a list of strings into a list of lists where each sublist contains the words of the corresponding string from the original list, split on the space character.\ndef list_of_strings_to_list_of_lists(list_of_strings):\n",
    "new_solution": "    return [string_to_list(string) for string in list_of_strings]\n",
    "test_code": "assert list_of_strings_to_list_of_lists(['hello world', 'python is fun']) == [['hello', 'world'], ['python', 'is', 'fun']]\nassert list_of_strings_to_list_of_lists(['']) == [['']]\nassert list_of_strings_to_list_of_lists(['singleword']) == [['singleword']]"
  },
  {
    "id": 329,
    "raw_problem": "# Write a function to check if the given array represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\ndef check_min_heap_helper(arr, i):\n",
    "raw_solution": "    if 2 * i + 2 > len(arr):\n      return True\n    left_child = (arr[i] <= arr[2 * i + 1]) and check_min_heap_helper(arr, 2 * i + 1)\n    right_child = (2 * i + 2 == len(arr)) or  \\\n                (arr[i] <= arr[2 * i + 2] and \\\n                 check_min_heap_helper(arr, 2 * i + 2))\n    return left_child and right_child\ndef check_min_heap(arr):\n  return check_min_heap_helper(arr, 0)\n",
    "new_problem": "# Given a list of arrays, determine if each array represents a min heap. Return a list of boolean values where each value indicates whether the corresponding array is a min heap or not.\ndef check_min_heaps(arrays):\n",
    "new_solution": "    return [check_min_heap(arr) for arr in arrays]\n",
    "test_code": "assert check_min_heaps([[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [1, 3, 2, 4, 5]]) == [True, False, True]"
  }
]
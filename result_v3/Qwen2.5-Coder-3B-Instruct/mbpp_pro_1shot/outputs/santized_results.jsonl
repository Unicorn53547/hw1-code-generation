{"task_id": 290, "completion": "    return string.replace(' ', '%20')\n\n# Given a list of strings, replace all spaces in each string with '%20' and then concatenate all the modified strings into a single string. Finally, split the concatenated string by '%20' and return the resulting list of substrings.\ndef process_strings(string_list):\n    # First, replace all spaces in each string in the list\n    modified_strings = [replace_spaces(s) for s in string_list]\n    # Concatenate all the modified strings into a single string\n    concatenated_string = ''.join(modified_strings)\n    # Split the concatenated string by '%20' and return the resulting list of substrings\n    return concatenated_string.split('%20')\n\n"}
{"task_id": 201, "completion": "    # Use regular expression to find all adverbs in the sentence\n    adverbs = re.findall(r'\\b\\w+ly\\b', text)\n    # If no adverbs are found, return an empty list\n    if not adverbs:\n        return []\n    # Return the first adverb and its position\n    return [(text.index(adverbs[0]), text.index(adverbs[0]) + len(adverbs[0]), adverbs[0])]\n\n# Write a function to find all adverbs and their positions in multiple sentences. The function should return a list of tuples where each tuple contains the start position, end position, and the adverb for each sentence.\nimport re\n\ndef find_all_adverbs_positions(sentences):\n    # Initialize an empty list to store the results\n    results = []\n    # Iterate over each sentence in the input list\n    for sentence in sentences:\n        # Find the first adverb and its position in the sentence\n        adverb_position = find_adverb_position(sentence)\n        # If an adverb is found, add it to the results list\n        if adverb_position:\n            results.append(adverb_position)\n    # Return the list of results\n    return results\n\n"}
{"task_id": 234, "completion": "    return string.swapcase()\n\n# Given a list of strings, write a function to toggle the case of all characters in each string and then concatenate the results into a single string, with each toggled string separated by a space.\ndef toggle_and_concatenate(strings):\n    toggled_strings = [toggle_string(s) for s in strings]\n    return ' '.join(toggled_strings)\n\n"}
{"task_id": 25, "completion": "    # Base case: There is one way to partition a set of size 0\n    if n == 0:\n        return 1\n    # Initialize the Bell number array\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    # Fill the Bell number array using the recurrence relation\n    for i in range(1, n + 1):\n        bell[i] = sum(bell[j] for j in range(i))\n    return bell[n]\n\n# Given a list of integers representing the sizes of sets, write a function to find the total number of ways to partition all these sets combined.\ndef total_bell_numbers(sizes):\n    # Calculate the total number of ways to partition all sets combined\n    total_ways = 1\n    for size in sizes:\n        total_ways *= bell_number(size)\n    return total_ways\n\n"}
{"task_id": 39, "completion": "    # The formula for the nth centered hexagonal number is 3n(n-1) + 1\n    return 3 * n * (n - 1) + 1\n\n# Given a list of integers representing the positions of points on a hexagonal grid, write a function to calculate the sum of the centered hexagonal numbers for each point in the list.\ndef sum_centered_hexagonal_numbers(points):\n    # Use the centered_hexagonal_number function to calculate the centered hexagonal number for each point\n    return sum(centered_hexagonal_number(point) for point in points)\n\n"}
{"task_id": 362, "completion": "    count = 0\n    for item in input_list:\n        if isinstance(item, list):\n            count += 1\n    return count\n\n# Write a Python function to count the number of lists in a given list of lists of lists. The function should recursively count all the lists at any depth.\ndef count_lists_recursive(input_list):\n    count = 0\n    for item in input_list:\n        if isinstance(item, list):\n            count += 1\n            count += count_lists_recursive(item)\n    return count\n\nassert count_lists_recursive([[1, 2], [3, [4, 5]], 6]) == 3\n"}
{"task_id": 102, "completion": "    return str1.replace(' ', char)\n\n# Write a function that takes in a list of strings and a character. The function should replace all blank spaces in each string with the given character, and then concatenate all the modified strings into a single string. Finally, return the concatenated string.\ndef replace_and_concatenate(str_list, char):\n    modified_strings = [replace_blank(s, char) for s in str_list]\n    return ''.join(modified_strings)\n\nassert replace_and_concatenate(['hello world', 'goodbye space'], '-') == 'hello-worldgoodbye-space'\n"}
{"task_id": 373, "completion": "    max_sum = float('-inf')\n    max_list = None\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list\n\n# Given a list of lists of lists, where each sub-list contains integers, write a function that returns the list of lists whose sum of elements is the highest among all sub-lists. If there are multiple lists with the same highest sum, return the first one encountered.\ndef max_sum_list_of_lists(list_of_lists):\n    max_sum = float('-inf')\n    max_list = None\n    for lst in list_of_lists:\n        current_sum = sum(max_sum_list(lst))\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list\n\nassert max_sum_list_of_lists([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]) == [[5, 6], [7, 8]]\n"}
{"task_id": 65, "completion": "    return string.split(' ')\n\n# Write a function to convert a list of strings into a list of lists where each sublist contains the words of the corresponding string from the original list, split on the space character.\ndef list_of_strings_to_list_of_lists(list_of_strings):\n    return [string_to_list(s) for s in list_of_strings]\n\nassert list_of_strings_to_list_of_lists(['hello world', 'python is fun']) == [['hello', 'world'], ['python', 'is', 'fun']]\n"}
{"task_id": 329, "completion": "    n = len(arr)\n    # Base case: if the current index is greater than or equal to the number of elements, return True\n    if i >= n:\n        return True\n    # Check if the current element is greater than its children\n    if i * 2 + 1 < n and arr[i] > arr[i * 2 + 1]:\n        return False\n    if i * 2 + 2 < n and arr[i] > arr[i * 2 + 2]:\n        return False\n    # Recursively check the left and right subtrees\n    return check_min_heap_helper(arr, i * 2 + 1) and check_min_heap_helper(arr, i * 2 + 2)\n\n# Given a list of arrays, determine if each array represents a min heap. Return a list of boolean values where each value indicates whether the corresponding array is a min heap or not.\ndef check_min_heaps(arrays):\n    result = []\n    for arr in arrays:\n        result.append(check_min_heap_helper(arr, 0))\n    return result\n\n"}
